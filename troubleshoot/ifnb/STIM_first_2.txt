#STIM FIRST
R version 4.2.2 (2022-10-31) -- "Innocent and Trusting"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(Seurat)
Registered S3 method overwritten by 'data.table':
  method           from
  print.data.table     
Registered S3 method overwritten by 'htmlwidgets':
  method           from         
  print.htmlwidget tools:rstudio
Attaching SeuratObject
> library(SeuratData)
── Installed datasets ─────────────────────────────────────── SeuratData v0.2.2 ──
✔ ifnb 3.0.0                             

─────────────────────────────────────── Key ──────────────────────────────────────
✔ Dataset loaded successfully
❯ Dataset built with a newer version of Seurat than installed
❓ Unknown version of Seurat installed

> library(patchwork)
> 
> # install dataset
> InstallData("ifnb")
Warning: The following packages are already installed and will not be reinstalled: ifnb
> 
> # load dataset
> LoadData("ifnb")
An object of class Seurat 
14053 features across 13999 samples within 1 assay 
Active assay: RNA (14053 features, 0 variable features)
> 
> # split the dataset into a list of two seurat objects (stim and CTRL)
> ifnb.list <- SplitObject(ifnb, split.by = "stim")
> 
> ###HERE###
> #change the order of ifnb.list
> ifnb.list <- c(STIM=ifnb.list$STIM, CTRL=ifnb.list$CTRL)
> ###CLOSE###
> 
> # normalize and identify variable features for each dataset independently
> ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
+     x <- NormalizeData(x)
+     x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
+ })
Performing log-normalization
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Calculating gene variances
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Calculating feature variances of standardized and clipped values
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Performing log-normalization
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Calculating gene variances
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Calculating feature variances of standardized and clipped values
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
> 
> # select features that are repeatedly variable across datasets for integration
> features <- SelectIntegrationFeatures(object.list = ifnb.list)
> 
> immune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, anchor.features = features)
Scaling features for provided objects
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=02s  
Finding all pairwise anchors
  |                                                  | 0 % ~calculating  Running CCA
Merging objects
Finding neighborhoods
Finding anchors
	Found 16390 anchors
Filtering anchors
	Retained 6080 anchors
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=06m 10s
> 
> # this command creates an 'integrated' data assay
> immune.combined <- IntegrateData(anchorset = immune.anchors)
Merging dataset 2 into 1
Extracting anchors for merged samples
Finding integration vectors
Finding integration vector weights
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Integrating data
> 
> # specify that we will perform downstream analysis on the corrected data note that the
> # original unmodified data still resides in the 'RNA' assay
> DefaultAssay(immune.combined) <- "integrated"
> 
> # Run the standard workflow for visualization and clustering
> immune.combined <- ScaleData(immune.combined, verbose = FALSE)
> immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)
> immune.combined <- RunUMAP(immune.combined, reduction = "pca", dims = 1:30)
Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric
To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'
This message will be shown once per session17:23:50 UMAP embedding parameters a = 0.9922 b = 1.112
17:23:50 Read 13999 rows and found 30 numeric columns
17:23:50 Using Annoy for neighbor search, n_neighbors = 30
17:23:50 Building Annoy index with metric = cosine, n_trees = 50
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
17:23:53 Writing NN index file to temp file /var/folders/nc/63w45yy90m5ccjdkylklyyhc0000gq/T//RtmpNu74rL/file10e9483d4aa7
17:23:53 Searching Annoy index using 1 thread, search_k = 3000
17:24:00 Annoy recall = 100%
17:24:01 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30
17:24:03 Initializing from normalized Laplacian + noise (using irlba)
17:24:04 Commencing optimization for 200 epochs, with 620750 positive edges
Using method 'umap'
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
17:24:19 Optimization finished
> immune.combined <- FindNeighbors(immune.combined, reduction = "pca", dims = 1:30)
Computing nearest neighbor graph
Computing SNN
> immune.combined <- FindClusters(immune.combined, resolution = 0.5)
Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck

Number of nodes: 13999
Number of edges: 568912

Running Louvain algorithm...
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Maximum modularity in 10 random starts: 0.9068
Number of communities: 15
Elapsed time: 3 seconds
> 
> 
> #saveRDS(immune.combined, "tutorial_ifnb_CTRL_first_2.rds")
> saveRDS(immune.combined, "tutorial_ifnb_STIM_first_2.rds")
> 
> 